<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <title>Luke-Bot</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@stlite/mountable@0.58.1/build/stlite.css" />
    <style>
      body { margin: 0; background-color: #0e1117; }
    </style>
  </head>
  <body>
    <div id="stlite"></div>
    <script src="https://cdn.jsdelivr.net/npm/@stlite/mountable@0.58.1/build/stlite.js"></script>
    <script>
      stlite.mount({
        requirements: ["requests", "pandas", "pyodide-http"],
        entrypoint: "app.py",
        files: {
          "config.py": `
GROQ_API_KEY = "YOUR_GROQ_API_KEY"
WOLFRAM_APPID = "YOUR_WOLFRAM_APPID"
NCBI_API_KEY = "YOUR_NCBI_API_KEY"
`,
          "app.py": `
import streamlit as st
import requests
import json
import xml.etree.ElementTree as ET
import pandas as pd
import pyodide_http
from config import GROQ_API_KEY, WOLFRAM_APPID, NCBI_API_KEY

pyodide_http.patch_all()

APP_NAME = "Luke-Bot"
st.set_page_config(page_title=APP_NAME, layout="wide")

st.markdown("""
<style>
    .main { background-color: #0e1117; }
</style>
""", unsafe_allow_html=True)

if "messages" not in st.session_state:
    st.session_state.messages = []

st.sidebar.title(APP_NAME)

st.sidebar.subheader("API設定")
user_gemini_key = st.sidebar.text_input("Gemini API Key を入力", type="password")

st.sidebar.subheader("分野設定")
category_main = st.sidebar.selectbox("大カテゴリー", ["数学", "物理", "天文学", "工学・技術", "プログラミング"])

category_mid = "未設定"
detail_item = "未設定"

if category_main == "数学":
    category_mid = st.sidebar.selectbox("中カテゴリー", ["代数学", "幾何学", "解析学", "数理論理学・基礎論", "確率・統計学", "ミレニアム懸賞問題・未解決問題"])
    if category_mid == "代数学":
        detail_item = st.sidebar.selectbox("詳細項目", ["群・環・体", "線形代数学", "数論", "代数幾何学", "表現論"])
    elif category_mid == "幾何学":
        detail_item = st.sidebar.selectbox("詳細項目", ["微分幾何学", "位相幾何学", "シンプレクティック幾何学", "フラクタル幾何学"])
    elif category_mid == "解析学":
        detail_item = st.sidebar.selectbox("詳細項目", ["実・複素解析", "微分方程式", "関数解析学", "変分法"])
    elif category_mid == "数理論理学・基礎論":
        detail_item = st.sidebar.selectbox("詳細項目", ["集合論", "圏論"])
    elif category_mid == "確率・統計学":
        detail_item = st.sidebar.selectbox("詳細項目", ["確率過程", "数理統計学"])
    elif category_mid == "ミレニアム懸賞問題・未解決問題":
        detail_item = st.sidebar.selectbox("詳細項目", ["ヤン–ミルズ方程式と質量ギャップ問題", "リーマン予想", "P≠NP予想", "ナビエ–ストークス方程式の解の存在と滑らかさ", "ホッジ予想", "BSD予想", "素数ギャップ", "コラッツ予想", "ゴールドバッハ予想", "双子素数予想", "接吻数問題"])

elif category_main == "物理":
    category_mid = st.sidebar.selectbox("中カテゴリー", ["古典力学", "電磁気学", "相対性理論", "量子力学", "熱力学・統計力学"])
    if category_mid == "古典力学":
        detail_item = st.sidebar.selectbox("詳細項目", ["ニュートン力学", "解析力学", "流体力学"])
    elif category_mid == "相対性理論":
        detail_item = st.sidebar.selectbox("詳細項目", ["特殊相対論", "一般相対論"])
    elif category_mid == "量子力学":
        detail_item = st.sidebar.selectbox("詳細項目", ["波動力学", "量子統計力学", "場の量子論"])
    else:
        detail_item = st.sidebar.selectbox("詳細項目", ["基本法則", "応用物理研究"])

elif category_main == "天文学":
    category_mid = st.sidebar.selectbox("中カテゴリー", ["天体力学", "恒星物理学", "銀河天文学", "宇宙論", "観測天文学"])
    if category_mid == "宇宙論":
        detail_item = st.sidebar.selectbox("詳細項目", ["ビッグバン理論", "インフレーション理論", "ダークマター・ダークエネルギー"])
    elif category_mid == "観測天文学":
        detail_item = st.sidebar.selectbox("詳細項目", ["電波天文学", "X線・ガンマ線天文学", "重力波天文学"])
    else:
        detail_item = st.sidebar.selectbox("詳細項目", ["天体観測", "宇宙の構造"])

elif category_main == "工学・技術":
    category_mid = st.sidebar.selectbox("中カテゴリー", ["機械工学", "電気電子工学", "通信工学", "土木・建築工学", "材料工学", "航空宇宙工学"])
    detail_item = st.sidebar.selectbox("詳細項目", ["技術の実装", "設計理論", "実用化"])

elif category_main == "プログラミング":
    category_mid = st.sidebar.selectbox("中カテゴリー", ["理論計算機科学", "ソフトウェア工学", "データサイエンス・AI", "ネットワークとセキュリティ", "HCI"])
    if category_mid == "理論計算機科学":
        detail_item = st.sidebar.selectbox("詳細項目", ["アルゴリズムとデータ構造", "計算複雑性理論", "型理論"])
    elif category_mid == "データサイエンス・AI":
        detail_item = st.sidebar.selectbox("詳細項目", ["機械学習", "自然言語処理", "コンピュータビジョン"])
    else:
        detail_item = st.sidebar.selectbox("詳細項目", ["システム構築", "セキュリティ対策"])

mode = st.sidebar.radio("対話モード", ["一般会話", "専門家対話", "論文検索・要約", "コーダーモード"])
token_slider = st.sidebar.slider("会話の長さ", 1, 5, 3)
expertise_slider = st.sidebar.slider("専門性", 1, 5, 3)

if st.sidebar.button("履歴消去"):
    st.session_state.messages = []
    st.rerun()

def call_groq(prompt, system_prompt=""):
    url = "https://api.groq.com/openai/v1/chat/completions"
    headers = {"Authorization": f"Bearer {GROQ_API_KEY}", "Content-Type": "application/json"}
    temp = 0.1 + (expertise_slider * 0.15)
    max_tokens = token_slider * 600
    payload = {
        "model": "llama-3.3-70b-versatile",
        "messages": [
            {"role": "system", "content": f"あなたは{APP_NAME}です。日本語で回答してください。専門性レベル: {expertise_slider}/5。 {system_prompt}"},
            {"role": "user", "content": prompt}
        ],
        "temperature": temp,
        "max_tokens": max_tokens
    }
    try:
        resp = requests.post(url, json=payload, headers=headers)
        return resp.json()['choices'][0]['message']['content']
    except:
        return "Groq API接続エラー"

def call_gemini(prompt, system_prompt=""):
    if not user_gemini_key:
        return "エラー: Gemini API Key が入力されていません。"
    model_name = "models/gemini-1.5-flash"
    url = f"https://generativelanguage.googleapis.com/v1beta/{model_name}:generateContent?key={user_gemini_key}"
    full_system = f"あなたは{APP_NAME}です。分野: {category_main} {category_mid} {detail_item} {system_prompt}"
    payload = {
        "contents": [{"parts": [{"text": f"System: {full_system}\\n\\nUser: {prompt}"}]}],
        "generationConfig": {"maxOutputTokens": token_slider * 600}
    }
    try:
        resp = requests.post(url, json=payload, timeout=30)
        res_json = resp.json()
        if resp.status_code == 200:
            if 'candidates' in res_json and res_json['candidates']:
                return res_json['candidates'][0]['content']['parts'][0]['text']
            return "応答なし"
        return f"Gemini Error: {res_json.get('error', {}).get('message', 'Unknown')}"
    except Exception as e:
        return str(e)

def search_arxiv(query):
    base_url = "https://export.arxiv.org/api/query?"
    params = f"search_query=all:{query}&start=0&max_results=3"
    try:
        resp = requests.get(base_url + params)
        root = ET.fromstring(resp.content)
        results = []
        for entry in root.findall('{http://www.w3.org/2005/Atom}entry'):
            title = entry.find('{http://www.w3.org/2005/Atom}title').text
            summary = entry.find('{http://www.w3.org/2005/Atom}summary').text
            link = entry.find('{http://www.w3.org/2005/Atom}id').text
            results.append(f"Title: {title}\\nSummary: {summary[:200]}...\\nURL: {link}")
        return "\\n\\n".join(results) if results else "該当論文なし"
    except:
        return "arXivエラー"

def call_wolfram(query):
    url = f"https://api.wolframalpha.com/v1/result?appid={WOLFRAM_APPID}&i={query}"
    try:
        resp = requests.get(url)
        return resp.text if resp.status_code == 200 else "No result"
    except:
        return "WolframAlphaエラー"

st.title(APP_NAME)
display_context = f"{category_main} > {category_mid} > {detail_item} | {mode}"
st.text(display_context)

for message in st.session_state.messages:
    with st.chat_message(message["role"]):
        st.markdown(message["content"])

if prompt := st.chat_input("メッセージを入力"):
    st.session_state.messages.append({"role": "user", "content": prompt})
    with st.chat_message("user"):
        st.markdown(prompt)

    with st.spinner("処理中"):
        response = ""
        if mode == "コーダーモード":
            response = call_groq(prompt, "Programming expert")
        elif mode == "論文検索・要約":
            response = search_arxiv(prompt)
        elif mode == "専門家対話":
            if "数学" in category_main:
                wa_res = call_wolfram(prompt)
                if "No result" in wa_res:
                    response = call_groq(prompt, f"Expert in {detail_item}")
                else:
                    response = call_groq(f"Wolfram Result: {wa_res}\\nQuery: {prompt}", f"Expert in {detail_item}")
            else:
                response = call_groq(prompt, f"Expert in {detail_item}")
        else:
            response = call_gemini(prompt, "Assistant")

    with st.chat_message("assistant"):
        st.markdown(response)
    st.session_state.messages.append({"role": "assistant", "content": response})
`
        }
      });
    </script>
  </body>
</html>
